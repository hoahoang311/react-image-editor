import _extends from"@babel/runtime/helpers/extends";import _asyncToGenerator from"@babel/runtime/helpers/asyncToGenerator";import _defineProperty from"@babel/runtime/helpers/defineProperty";import _regeneratorRuntime from"@babel/runtime/regenerator";function ownKeys(a,b){var c=Object.keys(a);if(Object.getOwnPropertySymbols){var d=Object.getOwnPropertySymbols(a);b&&(d=d.filter(function(b){return Object.getOwnPropertyDescriptor(a,b).enumerable})),c.push.apply(c,d)}return c}function _objectSpread(a){for(var b,c=1;c<arguments.length;c++)b=null==arguments[c]?{}:arguments[c],c%2?ownKeys(Object(b),!0).forEach(function(c){_defineProperty(a,c,b[c])}):Object.getOwnPropertyDescriptors?Object.defineProperties(a,Object.getOwnPropertyDescriptors(b)):ownKeys(Object(b)).forEach(function(c){Object.defineProperty(a,c,Object.getOwnPropertyDescriptor(b,c))});return a}import React,{useEffect,useRef,useMemo}from"react";import{Ellipse,Image,Line,Rect,Transformer}from"react-konva";import Konva from"konva";import*as faceapi from"face-api.js";import{useStore}from"../../../hooks";import{SET_CROP,SET_FEEDBACK}from"../../../actions";import{CUSTOM_CROP,ELLIPSE_CROP,FEEDBACK_STATUSES,ORIGINAL_CROP,TOOLS_IDS}from"../../../utils/constants";import{boundDragging,boundResizing}from"./TransformersLayer.utils";import TextNode from"../DesignLayer/AnnotationNodes/TextNode";var noEffectTextDimensions={width:200,height:100},CropTransformer=function(a){var b=a.setFaceBox,c=a.faceBox,d=a.setTopToChin,e=useStore(),f=e.dispatch,g=e.theme,h=e.designLayer,i=e.originalImage,j=e.shownImageDimensions,k=e.adjustments,l=void 0===k?{}:k,m=l.crop,n=void 0===m?{}:m,o=l.isFlippedX,p=l.isFlippedY,q=e.resize,r=void 0===q?{}:q,s=e.config,u=e.t,t=useRef(),v=useRef(),w=useRef(),z=useRef(),A=s[TOOLS_IDS.CROP],B=useMemo(function(){var a;return _objectSpread(_objectSpread({},A),{},{lockCropAreaAt:null!==(a=n.lockCropAreaAt)&&void 0!==a?a:null===A||void 0===A?void 0:A.lockCropAreaAt})},[n.lockCropAreaAt,A]),C=B.lockCropAreaAt,D=n.ratio||B.ratio,E=D===CUSTOM_CROP,F=D===ELLIPSE_CROP,G=function a(){return D===ORIGINAL_CROP?i.width/i.height:D},H=function c(a,b){var d=a.width,e=a.height,g=a.x,h=a.y,i={x:g,y:h,width:d,height:e},j=n.width>=r.width&&n.height>=r.height;r.width&&r.height&&(d<r.width||e<r.height)&&j&&f({type:SET_FEEDBACK,payload:{feedback:{message:u("cropSizeLowerThanResizedWarning"),status:FEEDBACK_STATUSES.WARNING}}}),f({type:SET_CROP,payload:_objectSpread(_objectSpread(_objectSpread({},n),i),{},{dismissHistory:b})})},I=function c(a,b){var d,e,f=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{noScale:!0};v.current&&t.current&&v.current.nodes([t.current]);var g=z.current,h={width:a,height:b,x:null!==(d=n.x)&&void 0!==d?d:0,y:null!==(e=n.y)&&void 0!==e?e:0};H(boundResizing(h,h,_objectSpread(_objectSpread({},g),{},{abstractX:0,abstractY:0}),!(E||F)&&G(),_objectSpread(_objectSpread({},B),f)),!0)};useEffect(function(){return h&&v.current&&t.current&&(w.current&&w.current.cache(),v.current.nodes([t.current])),function(){w.current&&w.current.clearCache()}},[h,i,j]),useEffect(function(){if(j&&(z.current=j,"undefined"!=typeof j.x&&j.width)){var a,b;I(null!==(a=n.width)&&void 0!==a?a:j.width,null!==(b=n.height)&&void 0!==b?b:j.height)}},[D,j,B]);var J=useMemo(function(){var a=j.width,b=j.height,c=i.width,d=i.height;return{scaleX:a/c,scaleY:b/d}});if(useEffect(function(){if(!c||c.src!==i.src){var a=function(){var a=_asyncToGenerator(_regeneratorRuntime.mark(function a(){var b;return _regeneratorRuntime.wrap(function c(a){for(;1;)switch(a.prev=a.next){case 0:return b="https://supachaic.github.io/react-face-recognition/models",a.next=3,faceapi.loadTinyFaceDetectorModel(b);case 3:return a.next=5,faceapi.loadFaceLandmarkTinyModel(b);case 5:return a.next=7,faceapi.loadFaceRecognitionModel(b);case 7:case"end":return a.stop()}},a)}));return function b(){return a.apply(this,arguments)}}(),d=function(){var a=_asyncToGenerator(_regeneratorRuntime.mark(function a(){var c,d,e,f,g,h,j;return _regeneratorRuntime.wrap(function k(a){for(;1;)switch(a.prev=a.next){case 0:return a.next=2,faceapi.detectSingleFace(i,new faceapi.TinyFaceDetectorOptions);case 2:c=a.sent,c&&(d=c.box,e=d.x,f=d.y,g=d.width,h=d.height,j={x:e*J.scaleX,y:f*J.scaleY,width:g*J.scaleX,height:h*J.scaleY,src:i.src},b(j));case 4:case"end":return a.stop()}},a)}));return function b(){return a.apply(this,arguments)}}();a().then(d)}},[i,J]),useEffect(function(){if(i&&i.complete&&0!==i.naturalWidth&&c){var a=document.createElement("canvas");a.width=i.width,a.height=i.height;var e=a.getContext("2d");if(e){e.drawImage(i,0,0);for(var f=e.getImageData(0,0,i.width,i.height),h=f.data,j=0;j<i.height;j+=1)for(var k=0;k<i.width;k+=1){var l=4*(j*i.width+k),m=h[l],n=h[l+1],o=h[l+2],p=200<m&&200<n&&200<o;if(!p&&5<j&&5<k&&k<i.width-5)return void d(c.height+c.y-j*J.scaleY)}}}},[i,J,c]),!h)return null;var K,L=(C||n.noEffect)&&[]||(E||F?void 0:["top-left","bottom-left","top-right","bottom-right"]),M=function b(a){var c=!!(1<arguments.length&&void 0!==arguments[1])&&arguments[1];a.target&&H({width:a.target.width()*a.target.scaleX(),height:a.target.height()*a.target.scaleY(),x:a.target.x(),y:a.target.y()},c)};if(!n.width&&!n.height){var N=1>j.scaledBy?j.scaledBy:1,O=_objectSpread(_objectSpread({},j),{},{width:j.width/N,height:j.height/N});K=boundResizing(O,_objectSpread(_objectSpread({},O),{},{x:0,y:0}),_objectSpread(_objectSpread({},O),{},{abstractX:0,abstractY:0}),!(E||F)&&G(),B)}else K=n;var P=K,Q=P.x,R=void 0===Q?0:Q,x=P.y,S=void 0===x?0:x,y=P.width,T=P.height,U={x:R,y:S,ref:t,fill:"#FFFFFF",scaleX:1,scaleY:1,globalCompositeOperation:"destination-out",onDragEnd:C?void 0:M,onDragMove:C?void 0:function b(a){var c=a.target;c.setAttrs(boundDragging(c.attrs,z.current))},onTransformEnd:C?void 0:M,draggable:!C};return React.createElement(React.Fragment,null,React.createElement(Image,{image:i,x:o?j.width:0,y:p?j.height:0,width:j.width,height:j.height,filters:[Konva.Filters.Blur,Konva.Filters.Brighten],blurRadius:10,brightness:-.3,scaleX:o?-1:1,scaleY:p?-1:1,ref:w}),F?React.createElement(Ellipse,_extends({},U,{radiusX:y/2,radiusY:T/2,offset:{x:-y/2,y:-T/2}})):React.createElement(React.Fragment,null,React.createElement(Rect,_extends({},U,{width:n.noEffect?0:y,height:n.noEffect?0:T})),!B.showImageFrames&&React.createElement(Line,{points:[U.x+y/2,U.y,U.x+y/2,U.y+T],stroke:"red",strokeWidth:1}),!B.showImageFrames&&c&&React.createElement(Rect,{x:c.x,y:c.y,width:c.width,height:c.height,stroke:"red",strokeWidth:1})),n.noEffect&&React.createElement(TextNode,{name:"Text",id:"no-preview-text-node",text:u("cropItemNoEffect"),x:j.width/2-noEffectTextDimensions.width/2,y:j.height/2-noEffectTextDimensions.height/2,fontSize:20,fill:"#ffffff",stroke:"#ff0000",strokeWidth:.2,shadowColor:"#ff0000",shadowBlur:10,annotationEvents:{},align:"center",width:noEffectTextDimensions.width,height:noEffectTextDimensions.height}),React.createElement(Transformer,{centeredScaling:!1,flipEnabled:!1,rotateEnabled:!1,nodes:t.current?[t.current]:[],anchorSize:14,anchorCornerRadius:7,enabledAnchors:L,ignoreStroke:!1,anchorStroke:g.palette["accent-primary"],anchorFill:g.palette["access-primary"],anchorStrokeWidth:2,borderStroke:g.palette["accent-primary"],borderStrokeWidth:2,borderDash:[4],keepRatio:!E||!F,ref:v,boundBoxFunc:function c(a,b){return boundResizing(a,b,z.current,!(E||F)&&G(),B)}}))};CropTransformer.defaultProps={faceBox:null};export default CropTransformer;